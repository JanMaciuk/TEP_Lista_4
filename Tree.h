#ifndef treeDef
#define treeDef
#include <string>
#include <vector>
using namespace std;

const vector<string> operations2children = { "+", "-", "*", "/"};
const vector<string> operations1child = { "sin", "cos" };
const int multiplicationIndex = 2;
const int divisionIndex = 3;
const int IDconstant = 3;
const int IDvariable = 4;
const char minDigit = '0';
const char maxDigit = '9';
const char minSmalLetter = 'a';
const char maxSmallLetter = 'z';
const char minCapitalLetter = 'A';
const char maxCapitalLetter = 'Z';
const string defaultNodeValue = "1";
const string emptyString = "";
const string endLine = "\n";
const string space = " ";
const int baseNumber = 10;
const int maxChildrenCount = 2;

const char char_space = ' ';
const string command_enterTree = "enter";
const string notification_wrongCommand = "Wrong command, try again";
const string notification_exit = "Terminating the program";
const string notification_awaitingCommand = "Awaiting command to execute";
const string notification_ommitingInvalidChar = " is not valid in a variable name, ommiting";
const string notification_emptyVariableName = "Variable name cannot be empty, using default name: ";
const string notification_varNameOnlyNumbers = "Variable name cannot contain only numbers, appending default name: ";
const string notification_noTree = "No tree found, use enter command to create a new tree";
const string notification_printingTree = "Printing tree: ";
const string notification_printingExpression = "Constructed a tree using the expression: ";
const string notification_printingVars = "Printing variables: ";
const string notification_ommitingLeftovers = "Ommiting invalid values at the end of expression which couldnt be attached:";
const string notification_missingValue = " operator should be followed by a value, adding default: ";
const string notification_invalidVariablesNumber = "Wrong amount of variable values found";
const string notification_invalidVariableValue = " is not a valid value for a variable, a positive number required ";
const string notification_zeroNotAllowed = "entered numbers must be positive, zero is not supported, replacing with default value: ";
const string notification_overflow = "Integer overflow occured, use smaller values and consider result invalid, replaced by default: ";
const string defaultVarName = "x";


class CNode 
{

private:
	vector<CNode*> children;	// vector with children
	CNode *parent;					// parent of root is NULL
	string value;				// operation or constant or variable
	int type;						// 1 - operation with 1 child, 2 - operation with 2 children, 3 - constant, 4 - variable
	static string errMsg;						// error messages generated by all the nodes
	static int getType(string* value)			// return type of a string (operation, constant or variable), if its a variable, turns it into a valid variable name
	{
		// 1 - operation with 1 child, 2 - operation with 2 children, 3 - constant, 4 - variable (name is made valid)
		if (find(operations1child.begin(), operations1child.end(), *value) != operations1child.end()) { return 1; } // if value is in the list of operations with 1 child
		else if (find(operations2children.begin(), operations2children.end(), *value) != operations2children.end()) { return 2; } // if value is in the list of operators with 2 children
		else if (isNumber(*value)) // if value is a number/constant return 3
		{
			//ensure the number is not zero
			bool isZero = false;
			for (int i = 0; i < value->length(); i++)
			{
				if ((*value)[i] == minDigit) { isZero = true; }
			}
			if (isZero)
			{
				logError(notification_zeroNotAllowed + defaultNodeValue);
				*value = defaultNodeValue;
			}
			return IDconstant;
		}
		else // if value is a variable validate it
		{
			*value = validateVariableName(*value);
			return IDvariable;

		}

	};

	static bool isNumber(const string value)  // return true if string is a number
	{
		for (int i = 0; i < value.length(); i++)
		{ // if any character is not withing ascii range of digits, return false
			if (value[i] < minDigit || value[i] > maxDigit) { return false; }
		}
		return true;
	};
	
	static string validateVariableName(const string value)		// turn string into a valid variable name
	{
		// turn string into a valid variable name, requirements to be valid:
		// cannot be empty
		// cannot contain only numbers
		// can only contain letters and numbers

		string result = emptyString;
		for (int i = 0; i < value.length(); i++)
		{
			if ((value[i] >= minDigit && value[i] <= maxDigit) || (value[i] >= minSmalLetter && value[i] <= maxSmallLetter) || (value[i] >= minCapitalLetter && value[i] <= maxCapitalLetter))
			{
				result += value[i];
			}
			else // if character is not a letter or a number, print notification and ommit it
			{
				logError(value[i] + notification_ommitingInvalidChar);
			}
		}
		if (result == emptyString) // if variable name is empty, add default name to make it valid
		{
			logError(notification_emptyVariableName + defaultVarName);
			result = defaultVarName;
		}
		if (isNumber(result)) // if variable name is only numbers, add default name to the beginning to make it valid
		{
			logError(notification_varNameOnlyNumbers);
			result = defaultVarName + result;
		}
		return result;
	};

	static int strToInt(const string value, bool* overflow)		// convert string to int
	{
		// convert string to int
		// if overflow, set overflow to true
		// value must be a number (checked before call, function is private)
		*overflow = false;
		int result = 0;
		for (int i = 0; i < value.length(); i++)
		{
			result *= baseNumber;
			result += (value[i] - minDigit);
			if (result < 0) { *overflow = true; }

		}
		return result;
	};

public:
	
	CNode(const vector<string> expression, CNode* parentNode, int* currentIndex)					//Constructor from a string at index (calls next constructor)
	{
		parent = parentNode;
		string val = defaultNodeValue;
		if (*currentIndex < expression.size()) { val = expression[*currentIndex]; } // if there are values left in the vector, get the next one
		else
		{ // if there are no values left, notify user and use default value
			if (parentNode == NULL) { logError(notification_missingValue + defaultNodeValue); }
			else { logError(parentNode->value + notification_missingValue + defaultNodeValue); }
		}
		(*currentIndex)++;
		type = getType(&val); // get type of the value, if its a variable, turn it into a valid variable name
		value = val;
		//fill vector with NULL children to avoid accessing unalocated memory by [] operator
		for (int i = 0; i < maxChildrenCount; i++)
		{
			children.push_back(NULL);
		}
		if (type == 1) // if operation with 1 child, create left child only
		{
			children[0] = new CNode(expression, this, currentIndex);
			children[1] = NULL;
		}
		else if (type == 2) // if operation with 2 children, create left and right children 
		{
			children[0] = new CNode(expression, this, currentIndex);
			children[1] = new CNode(expression, this, currentIndex);
		}


	};
	vector<string> inOrderWalk(vector<string>* accumulator) const
	{
		if (this == NULL) { return *accumulator; }
		accumulator->push_back(value);
		children[0]->inOrderWalk(accumulator);
		children[1]->inOrderWalk(accumulator);
		return *accumulator;
	}
	
	vector<string> getVars(vector<string>* accumulator) const 		// return expression used to create the tree
	{
		if (this == NULL) { return *accumulator; }
		if ((this->type == IDvariable) && (find((*accumulator).begin(), (*accumulator).end(), (this->value)) == (*accumulator).end()))
		{ // if node is a variable and is not in the accumulator, add it
			accumulator->push_back(this->value);
		} // then walk throught the rest of the tree
		children[0]->getVars(accumulator);
		children[1]->getVars(accumulator);
		return *accumulator;
	};

	static double calculate(CNode* node, const vector<string> vars, const vector<double> values) // calculate expression using variables and values
	{
		if (node == NULL) { return 0; }

		else if (node->type == IDconstant)  // if its a constant, simply return its value
		{
			bool overflow;
			int value = strToInt(node->value, &overflow);
			if (overflow)
			{
				value = strToInt(defaultNodeValue, &overflow);
				logError(notification_overflow + defaultNodeValue);
			}
			return value;
		}

		else if (node->type == IDvariable) // if its a variable, find its value in values vector
		{
			int index = find(vars.begin(), vars.end(), node->value) - vars.begin(); // variable must be in the vars vector, so index will be valid (length is checked before)
			return values[index];
		}

		else if (node->type == 2) // if its a normal operator, calculate the values
		{
			double leftResult = calculate(node->children[0], vars, values);
			double rightResult = calculate(node->children[1], vars, values);

			if (node->value == operations2children[0])
			{
				if ((leftResult + rightResult) < 0) // Checking for overflow
				{
					logError(notification_overflow + defaultNodeValue);
					bool overflow;
					return strToInt(defaultNodeValue, &overflow);
				}
				return leftResult + rightResult;
			}
			else if (node->value == operations2children[1]) { return leftResult - rightResult; } // never overflows: both positive valid ints
			else if (node->value == operations2children[multiplicationIndex])
			{
				if ((leftResult * rightResult) < 0) // Checking for overflow
				{
					logError(notification_overflow + defaultNodeValue);
					bool overflow;
					return strToInt(defaultNodeValue, &overflow);
				}
				return leftResult * rightResult;
			}
			else if (node->value == operations2children[divisionIndex]) { return double(leftResult) / double(rightResult); }
		}

		else if (node->type == 1)
		{
			double childResult = calculate(node->children[0], vars, values);
			if (node->value == operations1child[0]) { return sin(childResult); }
			if (node->value == operations1child[1]) { return cos(childResult); }
		}

		return 0;
	};

	void inOrderWalkPrint() const;				//Print expression used to create the tree 
	
	void deleteTree() // delete the called node and all its descendants
	{
		if (this == NULL) { return; }
		for (int i = 0; i < maxChildrenCount; i++)
		{
			children[i]->deleteTree();
		}
		delete this;
	}
	
	static void logError(const string message)
	{
		errMsg += message + endLine;
	};
	static void logErrorSpace(const string message)
	{
		errMsg += message + space;
	};
	string getErrors(bool clear)
	{
		string result = errMsg;
		if (clear) errMsg = emptyString;
		return result;
	};
};


template< typename T > class CTree
{

private:
	CNode* root;
	
public:
	CTree(const vector<string> expression)
	{
		int index = 1;
		root = new CNode(expression, NULL, &index);
		// if position is not at the end of vector, print notification and ommit leftovers
		if (index < expression.size())
		{
			root->logErrorSpace(notification_ommitingLeftovers);
			for (int i = index; i < expression.size(); i++)
			{
				root->logErrorSpace(expression[i]);
			}
			root->logError(emptyString); // newline
		}
	};

	CTree(const CTree& otherInstance) // copy constructor
	{
		vector<string> expression = otherInstance.getExpression();
		expression.insert(expression.begin(), command_enterTree);
		int index = 1;
		root = new CNode(expression, NULL, &index);
		// No need to check for leftovers, original tree must be valid
	};

	CTree() // default constructor
	{
		root = NULL;
	};


	void operator=(const CTree& otherInstance)
	{
		// set current tree to a copy of another tree
		// if current tree is not empty, delete it
		if (this->root != NULL) { this->root->deleteTree(); }
		// create a new tree with the same expression as the other tree
		vector<string> expression = otherInstance.getExpression();
		expression.insert(expression.begin(), command_enterTree);
		int index = 1;
		this->root = new CNode(expression, NULL, &index);
	};

	CTree operator+(const CTree& otherInstance) const
	{
		// join two trees using operator+
		// if both trees are empty, return empty tree
		if (this->root == NULL && otherInstance.root == NULL) { return CTree(); }
		// if one of the trees is empty, return the other tree
		else if (this->root == NULL) { return otherInstance; }
		else if (otherInstance.root == NULL) { return *this; }
		// if both trees are not empty, create a new tree which is a copy of the first with second one added to it.
		else
		{
			// get expressions of both trees
			// remove last element from the first expression (it is a leaf)
			// add the second expression to the first one
			// create a new tree from the new expression
			vector<string> thisExpression = this->getExpression();
			vector<string> otherExpression = otherInstance.getExpression();
			thisExpression.pop_back();
			thisExpression.insert(thisExpression.begin(), command_enterTree); // add first placeholder to expression
			for (int i = 0; i < otherExpression.size(); i++)
			{
				thisExpression.push_back(otherExpression[i]);
			}
			CTree resultTree = CTree(thisExpression);
			return resultTree;

		}
	};

	void printExpression() const;								//Print expression used to create the tree
	string getErrors() const {
		return root->getErrors(false);
	};

	string clearErrors() {
		return root->getErrors(true);
	};

	vector<string> getExpression() const				//Return expression used to create the tree
	{
		vector<string> accumulator;
		vector<string> expression = root->inOrderWalk(&accumulator);
		return expression;
	};

	vector<string> getVars() const
	{
		vector<string> accumulator;
		vector<string> vars = root->getVars(&accumulator);
		return vars;
	}
	
	double calculate(vector<double> values) const			//Calculate expression using variable values
	{
		vector<string> accumulator;
		vector<string> vars = root->getVars(&accumulator);
		return CNode::calculate(root, vars, values);
	};

	bool isInitialized() const { return root != NULL; }; //Check if tree is initialized

	~CTree() { root->deleteTree(); }

};

#endif