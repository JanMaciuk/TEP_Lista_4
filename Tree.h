#pragma once
#include <string>
#include <vector>

const std::vector<std::string> operations2children = { "+", "-", "*", "/" };
const std::vector<std::string> operations1child = { "sin", "cos" };
const int multiplicationIndex = 2;
const int divisionIndex = 3;
const int IDconstant = 3;
const int IDvariable = 4;
const char minDigit = '0';
const char maxDigit = '9';
const char decimalSeparator = '.';
const char minSmalLetter = 'a';
const char maxSmallLetter = 'z';
const char minCapitalLetter = 'A';
const char maxCapitalLetter = 'Z';
const std::string defaultNodeValue = "1";
const std::string emptyString = "";
const std::string endLine = "\n";
const std::string space = " ";
const int baseNumber = 10;
const int maxChildrenCount = 2;


template <typename T> class CNode
{

private:
	std::vector<CNode*> children;	// vector with children
	CNode* parent;					// parent of root is NULL
	std::string value;				// operation or constant or variable
	int type;						// 1 - operation with 1 child, 2 - operation with 2 children, 3 - constant, 4 - variable
	static std::string errMsg;						// error messages generated by all the nodes
	static int getType(std::string* value);			// return type of a string (operation, constant or variable), if its a variable, turns it into a valid variable name
	static bool isNumber(const std::string value);  // return true if string is a number
	static std::string validateVariableName(const std::string value);	// turn string into a valid variable name
	static double strToNumber(const std::string value, bool* overflow);		// convert string to int

public:

	CNode(const std::vector<std::string> expression, CNode<T>* parent, int* index);			//Constructor from a string at index (calls next constructor)
	std::vector<std::string> inOrderWalk(std::vector<std::string>* accumulator) const;		// return expression used to create the tree
	std::vector<std::string> getVars(std::vector<std::string>* accumulator) const;			// return expression used to create the tree
	static double calculate(CNode<T>* node, const std::vector<std::string> vars, const std::vector<double> values); // calculate expression using variables and values
	void deleteTree();							// delete all children and itself
	static void logError(std::string msg);		// add error message
	static void logErrorSpace(std::string msg); // add error message terminated with a space instead of a newline
	static std::string getErrors(bool clear);	// return all error messages and clear them if flag is set
};


template <typename T> class CTree
{

private:
	CNode<T>* root;

public:
	CTree();													//Default constructor - empty tree
	CTree(const CTree& otherInstance);							//Copy constructor
	CTree(const std::vector<std::string> expression);			//Constructor from a vector of strings 

	void operator=(const CTree& otherInstance);					//Set current tree to a copy of another tree
	CTree operator+(const CTree& otherInstance) const;			//Return copy, result of adding another tree to current tree

	std::string getErrors() const;								//Return all errors generated by nodes
	std::string clearErrors();									//Clear all errors generated by nodes and clear them
	std::vector<std::string> getExpression() const;				//Return expression used to create the tree
	std::vector<std::string> getVars() const;					//Print all variables used in the expression
	double calculate(std::vector<double> values) const;			//Calculate expression using variable values
	inline bool isInitialized() const { return root != NULL; }; //Check if tree is initialized

	~CTree(); //Destructor
};

